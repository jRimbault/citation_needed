{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://citation_needed/./src/dom.ts","webpack://citation_needed/./src/main.ts"],"sourcesContent":["type EventNames = keyof HTMLElementEventMap\ntype Handler<Event extends EventNames> = (this: HTMLObjectElement, $event: HTMLElementEventMap[Event]) => unknown\ntype EventHandler<Event extends EventNames> = readonly [Handler<Event>, boolean | EventListenerOptions] | Handler<Event>\n\nexport type NodeDefinition =\n  | readonly [keyof HTMLElementTagNameMap, NodeOptions]\n  | readonly [keyof HTMLElementTagNameMap]\n  | Node\n\nexport interface NodeOptions {\n  readonly id?: string\n  readonly classList?: string | readonly string[]\n  readonly textContent?: string | { readonly html: string }\n  readonly attributes?: { readonly [attributeName: string]: string }\n  readonly children?: readonly NodeDefinition[]\n  readonly listeners?: { readonly [Event in EventNames]?: EventHandler<Event> }\n}\n\nexport function createNode<Tag extends keyof HTMLElementTagNameMap>(\n  tag: Tag,\n  options?: NodeOptions,\n): HTMLElementTagNameMap[Tag] {\n  const node = document.createElement(tag)\n  if (options === undefined) {\n    return node\n  }\n  if (options.id) {\n    node.id = options.id\n  }\n  return addListeners(\n    addChildren(\n      addAttributes(addContent(addClasses(node, options.classList), options.textContent), options.attributes),\n      options.children,\n    ),\n    options.listeners,\n  )\n}\n\nexport function debounce<E extends Event, F extends ($event: E) => unknown>(\n  eventHandler: F,\n  milliseconds = 500,\n): ($event: E) => Promise<ReturnType<F>> {\n  let timer: ReturnType<typeof setTimeout> | undefined\n  return ($event: E) => {\n    return new Promise(resolve => {\n      if (timer !== undefined) {\n        clearTimeout(timer)\n      }\n      timer = setTimeout(() => resolve(eventHandler($event) as ReturnType<F>), milliseconds)\n    })\n  }\n}\n\ntype Entry = [EventNames, EventHandler<EventNames> | undefined]\n\nfunction addListeners<E extends HTMLElement>(node: E, listeners?: NodeOptions['listeners']): E {\n  if (listeners) {\n    for (const [name, listener] of Object.entries(listeners) as Entry[]) {\n      if (listener instanceof Array) {\n        node.addEventListener(name, listener[0], listener[1])\n      } else if (listener instanceof Function) {\n        node.addEventListener(name, listener)\n      }\n    }\n  }\n  return node\n}\n\nfunction addChildren<E extends HTMLElement>(node: E, children: NodeOptions['children']): E {\n  function makeChild(params: NodeDefinition) {\n    if (params instanceof Node) {\n      return params\n    }\n    return createNode(params[0], params[1])\n  }\n  if (children && children.length > 0) {\n    for (const child of children) {\n      node.append(makeChild(child))\n    }\n  }\n  return node\n}\n\nfunction addAttributes<E extends HTMLElement>(node: E, attributes: NodeOptions['attributes']): E {\n  if (attributes) {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      node.setAttribute(attributeName, value)\n    }\n  }\n  return node\n}\n\nfunction addContent<E extends HTMLElement>(node: E, textContent: NodeOptions['textContent']): E {\n  if (textContent) {\n    if (typeof textContent === 'string') {\n      node.textContent = textContent\n    } else if (textContent.html) {\n      node.innerHTML = textContent.html\n    }\n  }\n  return node\n}\n\nfunction addClasses<E extends HTMLElement>(node: E, classList: NodeOptions['classList']): E {\n  if (classList) {\n    if (typeof classList === 'string' && classList !== '') {\n      node.classList.add(classList)\n    }\n    if (classList instanceof Array) {\n      node.classList.add(...classList.filter(Boolean))\n    }\n  }\n  return node\n}\n","import { createNode } from 'dom'\n\ntype StaticHtml = ReturnType<typeof getStaticHtmlElements>\ninterface Score {\n  score: number\n}\n\nconst DING = new Audio('sounds/ding-sound-effect_2.mp3')\n\nfunction main({ add, reset, save, playerName, playerList }: StaticHtml) {\n  const state = stateManager()\n  const scores = state.get()\n  playerList.append(...initialPlayingBoard(scores))\n  add.addEventListener('click', addPlayer(scores, playerList, playerName))\n  reset.addEventListener('click', () => {\n    Array.from(playerList.children).forEach(c => c.remove())\n    state.clear(scores)\n  })\n  save.addEventListener('click', () => state.set(scores))\n}\n\nfunction initialPlayingBoard(scores: Map<string, Score>) {\n  return Array.from(scores.keys(), playerName => makePlayerListItem(playerName, scores))\n}\n\nfunction addPlayer(scores: Map<string, Score>, list: HTMLUListElement, input: HTMLInputElement) {\n  return () => {\n    const playerName = input.value\n    if (playerName !== '' && !scores.has(playerName)) {\n      list.append(makePlayerListItem(playerName, scores))\n      input.value = ''\n    }\n  }\n}\n\nfunction makePlayerListItem(playerName: string, scores: Map<string, Score>) {\n  const playerScore = scores.set(playerName, scores.get(playerName) ?? { score: 0 }).get(playerName)\n  assert(playerScore !== undefined)\n  const scoreNode = createNode('span', { textContent: playerScore.score.toString() })\n  return createNode('li', {\n    textContent: `${playerName} : `,\n    children: [\n      scoreNode,\n      [\n        'button',\n        {\n          textContent: '+1',\n          listeners: {\n            click: () => {\n              playerScore.score += 1\n              scoreNode.textContent = playerScore.score.toString()\n              ;(DING.cloneNode(true) as HTMLAudioElement).play()\n            },\n          },\n        },\n      ],\n    ],\n  })\n}\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg)\n  }\n}\n\nfunction stateManager() {\n  const storageKey = 'scores'\n  return {\n    get: (): Map<string, Score> => {\n      const json: Record<string, Score> = JSON.parse(localStorage.getItem(storageKey) ?? '{}')\n      const scores = new Map<string, Score>()\n      for (const [playerName, playerScore] of Object.entries(json)) {\n        scores.set(playerName, playerScore)\n      }\n      return scores\n    },\n    set: (scores: Map<string, Score>) => {\n      const json: Record<string, Score> = {}\n      for (const [playerName, playerScore] of scores.entries()) {\n        json[playerName] = playerScore\n      }\n      localStorage.setItem(storageKey, JSON.stringify(json))\n    },\n    clear: (scores: Map<string, Score>) => {\n      scores.clear()\n      localStorage.setItem(storageKey, '{}')\n    },\n  } as const\n}\n\nfunction getStaticHtmlElements() {\n  function getByIdOptional<T extends HTMLElement = HTMLElement>(id: string): T | null {\n    return document.getElementById(id) as T | null\n  }\n  const add = getByIdOptional<HTMLButtonElement>('add-player')\n  const reset = getByIdOptional<HTMLButtonElement>('reset')\n  const save = getByIdOptional<HTMLButtonElement>('save')\n  const playerName = getByIdOptional<HTMLInputElement>('player-name')\n  const playerList = getByIdOptional<HTMLUListElement>('player-list')\n\n  assert(add !== null, 'Button to add player not found.')\n  assert(reset !== null, 'Button to erase game data not found.')\n  assert(save !== null, 'Button to save game data not found.')\n  assert(playerName !== null, \"Text input for players's names not found.\")\n  assert(playerList !== null, 'List element not found.')\n\n  return { add, reset, save, playerName, playerList } as const\n}\n\nwindow.onload = () => main(getStaticHtmlElements())\n"],"names":["createNode","tag","options","node","document","createElement","undefined","id","listeners","name","listener","Object","entries","Array","addEventListener","Function","addListeners","children","length","child","append","params","Node","addChildren","attributes","attributeName","value","setAttribute","addAttributes","textContent","html","innerHTML","addContent","classList","add","filter","Boolean","addClasses","DING","Audio","makePlayerListItem","playerName","scores","playerScore","set","get","score","assert","scoreNode","toString","click","cloneNode","play","condition","msg","Error","window","onload","reset","save","playerList","state","storageKey","json","JSON","parse","localStorage","getItem","Map","setItem","stringify","clear","stateManager","from","keys","initialPlayingBoard","list","input","has","addPlayer","forEach","c","remove","main","getByIdOptional","getElementById","getStaticHtmlElements"],"sourceRoot":""}