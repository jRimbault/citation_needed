{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://citation_needed/./src/dom.ts","webpack://citation_needed/./src/main.ts"],"sourcesContent":["type EventNames = keyof HTMLElementEventMap;\ntype Handler<Event extends EventNames> = (\n  this: HTMLObjectElement,\n  $event: HTMLElementEventMap[Event],\n) => unknown;\ntype EventHandler<Event extends EventNames> =\n  | readonly [Handler<Event>, boolean | EventListenerOptions]\n  | Handler<Event>;\n\nexport type NodeDefinition =\n  | readonly [keyof HTMLElementTagNameMap, NodeOptions]\n  | readonly [keyof HTMLElementTagNameMap]\n  | Node;\n\nexport interface NodeOptions {\n  readonly id?: string;\n  readonly classList?: string | readonly string[];\n  readonly textContent?: string | { readonly html: string };\n  readonly attributes?: { readonly [attributeName: string]: string };\n  readonly children?: readonly NodeDefinition[];\n  readonly listeners?: {\n    readonly [Event in EventNames]?: EventHandler<Event>;\n  };\n}\n\nexport function createNode<Tag extends keyof HTMLElementTagNameMap>(\n  tag: Tag,\n  options?: NodeOptions,\n): HTMLElementTagNameMap[Tag] {\n  const node = document.createElement(tag);\n  if (options === undefined) {\n    return node;\n  }\n  if (options.id) {\n    node.id = options.id;\n  }\n  return addListeners(\n    addChildren(\n      addAttributes(\n        addContent(addClasses(node, options.classList), options.textContent),\n        options.attributes,\n      ),\n      options.children,\n    ),\n    options.listeners,\n  );\n}\n\nexport function debounce<E extends Event, F extends ($event: E) => unknown>(\n  eventHandler: F,\n  milliseconds = 500,\n): ($event: E) => Promise<ReturnType<F>> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return ($event: E) => {\n    return new Promise((resolve) => {\n      if (timer !== undefined) {\n        clearTimeout(timer);\n      }\n      timer = setTimeout(\n        () => resolve(eventHandler($event) as ReturnType<F>),\n        milliseconds,\n      );\n    });\n  };\n}\n\ntype Entry = [EventNames, EventHandler<EventNames> | undefined];\n\nfunction addListeners<E extends HTMLElement>(\n  node: E,\n  listeners?: NodeOptions[\"listeners\"],\n): E {\n  if (listeners) {\n    for (const [name, listener] of Object.entries(listeners) as Entry[]) {\n      if (listener instanceof Array) {\n        node.addEventListener(name, listener[0], listener[1]);\n      } else if (listener instanceof Function) {\n        node.addEventListener(name, listener);\n      }\n    }\n  }\n  return node;\n}\n\nfunction addChildren<E extends HTMLElement>(\n  node: E,\n  children: NodeOptions[\"children\"],\n): E {\n  function makeChild(params: NodeDefinition) {\n    if (params instanceof Node) {\n      return params;\n    }\n    return createNode(params[0], params[1]);\n  }\n  if (children && children.length > 0) {\n    for (const child of children) {\n      node.append(makeChild(child));\n    }\n  }\n  return node;\n}\n\nfunction addAttributes<E extends HTMLElement>(\n  node: E,\n  attributes: NodeOptions[\"attributes\"],\n): E {\n  if (attributes) {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      node.setAttribute(attributeName, value);\n    }\n  }\n  return node;\n}\n\nfunction addContent<E extends HTMLElement>(\n  node: E,\n  textContent: NodeOptions[\"textContent\"],\n): E {\n  if (textContent) {\n    if (typeof textContent === \"string\") {\n      node.textContent = textContent;\n    } else if (textContent.html) {\n      node.innerHTML = textContent.html;\n    }\n  }\n  return node;\n}\n\nfunction addClasses<E extends HTMLElement>(\n  node: E,\n  classList: NodeOptions[\"classList\"],\n): E {\n  if (classList) {\n    if (typeof classList === \"string\" && classList !== \"\") {\n      node.classList.add(classList);\n    }\n    if (classList instanceof Array) {\n      node.classList.add(...classList.filter(Boolean));\n    }\n  }\n  return node;\n}\n","import { createNode } from \"dom\";\n\ntype StaticHtml = ReturnType<typeof getStaticHtmlElements>;\ninterface Score {\n  score: number;\n}\n\nconst DING = \"sounds/ding-sound-effect_2.mp3\";\n\nfunction main({ add, reset, save, playerName, playerList }: StaticHtml) {\n  const state = stateManager();\n  const scores = state.get();\n  playerList.append(...initialPlayingBoard(scores));\n  add.addEventListener(\"click\", addPlayer(scores, playerList, playerName));\n  reset.addEventListener(\"click\", () => {\n    Array.from(playerList.children).forEach((c) => c.remove());\n    state.clear(scores);\n  });\n  save.addEventListener(\"click\", () => state.set(scores));\n}\n\nfunction initialPlayingBoard(scores: Map<string, Score>) {\n  return Array.from(\n    scores.keys(),\n    (playerName) => makePlayerListItem(playerName, scores),\n  );\n}\n\nfunction addPlayer(\n  scores: Map<string, Score>,\n  list: HTMLUListElement,\n  input: HTMLInputElement,\n) {\n  return () => {\n    const playerName = input.value;\n    if (playerName !== \"\" && !scores.has(playerName)) {\n      list.append(makePlayerListItem(playerName, scores));\n      input.value = \"\";\n    }\n  };\n}\n\nfunction makePlayerListItem(playerName: string, scores: Map<string, Score>) {\n  const playerScore = scores.set(\n    playerName,\n    scores.get(playerName) ?? { score: 0 },\n  ).get(playerName);\n  assert(playerScore !== undefined);\n  const scoreNode = createNode(\"span\", {\n    textContent: playerScore.score.toString(),\n  });\n  return createNode(\"li\", {\n    textContent: `${playerName} : `,\n    children: [\n      scoreNode,\n      [\n        \"button\",\n        {\n          textContent: \"+1\",\n          listeners: {\n            click: () => {\n              playerScore.score += 1;\n              scoreNode.textContent = playerScore.score.toString();\n              new Audio(DING).play();\n            },\n          },\n        },\n      ],\n    ],\n  });\n}\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction stateManager() {\n  const storageKey = \"scores\";\n  return {\n    get: (): Map<string, Score> => {\n      const json: Record<string, Score> = JSON.parse(\n        localStorage.getItem(storageKey) ?? \"{}\",\n      );\n      const scores = new Map<string, Score>();\n      for (const [playerName, playerScore] of Object.entries(json)) {\n        scores.set(playerName, playerScore);\n      }\n      return scores;\n    },\n    set: (scores: Map<string, Score>) => {\n      const json: Record<string, Score> = {};\n      for (const [playerName, playerScore] of scores.entries()) {\n        json[playerName] = playerScore;\n      }\n      localStorage.setItem(storageKey, JSON.stringify(json));\n    },\n    clear: (scores: Map<string, Score>) => {\n      scores.clear();\n      localStorage.setItem(storageKey, \"{}\");\n    },\n  } as const;\n}\n\nfunction getStaticHtmlElements() {\n  function getByIdOptional<T extends HTMLElement = HTMLElement>(\n    id: string,\n  ): T | null {\n    return document.getElementById(id) as T | null;\n  }\n  const add = getByIdOptional<HTMLButtonElement>(\"add-player\");\n  const reset = getByIdOptional<HTMLButtonElement>(\"reset\");\n  const save = getByIdOptional<HTMLButtonElement>(\"save\");\n  const playerName = getByIdOptional<HTMLInputElement>(\"player-name\");\n  const playerList = getByIdOptional<HTMLUListElement>(\"player-list\");\n\n  assert(add !== null, \"Button to add player not found.\");\n  assert(reset !== null, \"Button to erase game data not found.\");\n  assert(save !== null, \"Button to save game data not found.\");\n  assert(playerName !== null, \"Text input for players's names not found.\");\n  assert(playerList !== null, \"List element not found.\");\n\n  return { add, reset, save, playerName, playerList } as const;\n}\n\nwindow.onload = () => main(getStaticHtmlElements());\n"],"names":["createNode","tag","options","node","document","createElement","undefined","id","listeners","name","listener","Object","entries","Array","addEventListener","Function","addListeners","children","length","child","append","params","Node","addChildren","attributes","attributeName","value","setAttribute","addAttributes","textContent","html","innerHTML","addContent","classList","add","filter","Boolean","addClasses","makePlayerListItem","playerName","scores","playerScore","set","get","score","assert","scoreNode","toString","click","Audio","play","condition","msg","Error","window","onload","reset","save","playerList","state","storageKey","json","JSON","parse","localStorage","getItem","Map","setItem","stringify","clear","stateManager","from","keys","initialPlayingBoard","list","input","has","addPlayer","forEach","c","remove","main","getByIdOptional","getElementById","getStaticHtmlElements"],"sourceRoot":""}