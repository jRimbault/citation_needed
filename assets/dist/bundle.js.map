{
  "version": 3,
  "sources": ["../../src/dom.ts", "../../src/main.ts"],
  "sourcesContent": ["type EventNames = keyof HTMLElementEventMap;\ntype Handler<Event extends EventNames> = (\n  this: HTMLObjectElement,\n  $event: HTMLElementEventMap[Event],\n) => unknown;\ntype EventHandler<Event extends EventNames> =\n  | readonly [Handler<Event>, boolean | EventListenerOptions]\n  | Handler<Event>;\n\nexport type NodeDefinition =\n  | readonly [keyof HTMLElementTagNameMap, NodeOptions]\n  | readonly [keyof HTMLElementTagNameMap]\n  | Node;\n\nexport interface NodeOptions {\n  readonly id?: string;\n  readonly classList?: string | readonly string[];\n  readonly textContent?: string | { readonly html: string };\n  readonly attributes?: { readonly [attributeName: string]: string };\n  readonly children?: readonly NodeDefinition[];\n  readonly listeners?: {\n    readonly [Event in EventNames]?: EventHandler<Event>;\n  };\n}\n\nexport function createNode<Tag extends keyof HTMLElementTagNameMap>(\n  tag: Tag,\n  options?: NodeOptions,\n): HTMLElementTagNameMap[Tag] {\n  const node = document.createElement(tag);\n  if (options === undefined) {\n    return node;\n  }\n  if (options.id) {\n    node.id = options.id;\n  }\n  return addListeners(\n    addChildren(\n      addAttributes(\n        addContent(addClasses(node, options.classList), options.textContent),\n        options.attributes,\n      ),\n      options.children,\n    ),\n    options.listeners,\n  );\n}\n\nexport function debounce<E extends Event, F extends ($event: E) => unknown>(\n  eventHandler: F,\n  milliseconds = 500,\n): ($event: E) => Promise<ReturnType<F>> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return ($event: E) => {\n    return new Promise((resolve) => {\n      if (timer !== undefined) {\n        clearTimeout(timer);\n      }\n      timer = setTimeout(\n        () => resolve(eventHandler($event) as ReturnType<F>),\n        milliseconds,\n      );\n    });\n  };\n}\n\ntype Entry = [EventNames, EventHandler<EventNames> | undefined];\n\nfunction addListeners<E extends HTMLElement>(\n  node: E,\n  listeners?: NodeOptions[\"listeners\"],\n): E {\n  if (listeners) {\n    for (const [name, listener] of Object.entries(listeners) as Entry[]) {\n      if (listener instanceof Array) {\n        node.addEventListener(name, listener[0], listener[1]);\n      } else if (listener instanceof Function) {\n        node.addEventListener(name, listener);\n      }\n    }\n  }\n  return node;\n}\n\nfunction addChildren<E extends HTMLElement>(\n  node: E,\n  children: NodeOptions[\"children\"],\n): E {\n  function makeChild(params: NodeDefinition) {\n    if (params instanceof Node) {\n      return params;\n    }\n    return createNode(params[0], params[1]);\n  }\n  if (children && children.length > 0) {\n    for (const child of children) {\n      node.append(makeChild(child));\n    }\n  }\n  return node;\n}\n\nfunction addAttributes<E extends HTMLElement>(\n  node: E,\n  attributes: NodeOptions[\"attributes\"],\n): E {\n  if (attributes) {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      node.setAttribute(attributeName, value);\n    }\n  }\n  return node;\n}\n\nfunction addContent<E extends HTMLElement>(\n  node: E,\n  textContent: NodeOptions[\"textContent\"],\n): E {\n  if (textContent) {\n    if (typeof textContent === \"string\") {\n      node.textContent = textContent;\n    } else if (textContent.html) {\n      node.innerHTML = textContent.html;\n    }\n  }\n  return node;\n}\n\nfunction addClasses<E extends HTMLElement>(\n  node: E,\n  classList: NodeOptions[\"classList\"],\n): E {\n  if (classList) {\n    if (typeof classList === \"string\" && classList !== \"\") {\n      node.classList.add(classList);\n    }\n    if (classList instanceof Array) {\n      node.classList.add(...classList.filter(Boolean));\n    }\n  }\n  return node;\n}\n", "import { createNode } from \"dom\";\n\ntype StaticHtml = ReturnType<typeof getStaticHtmlElements>;\ninterface Score {\n  score: number;\n}\n\nconst DING = \"sounds/ding-sound-effect_2.mp3\";\n\nfunction main({ add, reset, save, playerName, playerList }: StaticHtml) {\n  const state = stateManager();\n  const scores = state.get();\n  playerList.append(...initialPlayingBoard(scores));\n  add.addEventListener(\"click\", addPlayer(scores, playerList, playerName));\n  reset.addEventListener(\"click\", () => {\n    Array.from(playerList.children).forEach((c) => c.remove());\n    state.clear(scores);\n  });\n  save.addEventListener(\"click\", () => state.set(scores));\n}\n\nfunction initialPlayingBoard(scores: Map<string, Score>) {\n  return Array.from(\n    scores.keys(),\n    (playerName) => makePlayerListItem(playerName, scores),\n  );\n}\n\nfunction addPlayer(\n  scores: Map<string, Score>,\n  list: HTMLUListElement,\n  input: HTMLInputElement,\n) {\n  return () => {\n    const playerName = input.value;\n    if (playerName !== \"\" && !scores.has(playerName)) {\n      list.append(makePlayerListItem(playerName, scores));\n      input.value = \"\";\n    }\n  };\n}\n\nfunction makePlayerListItem(playerName: string, scores: Map<string, Score>) {\n  const playerScore = scores.set(\n    playerName,\n    scores.get(playerName) ?? { score: 0 },\n  ).get(playerName);\n  assert(playerScore !== undefined);\n  const scoreNode = createNode(\"span\", {\n    textContent: playerScore.score.toString(),\n  });\n  return createNode(\"li\", {\n    textContent: `${playerName} : `,\n    children: [\n      scoreNode,\n      [\n        \"button\",\n        {\n          textContent: \"+1\",\n          listeners: {\n            click: () => {\n              playerScore.score += 1;\n              scoreNode.textContent = playerScore.score.toString();\n              new Audio(DING).play();\n            },\n          },\n        },\n      ],\n    ],\n  });\n}\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction stateManager() {\n  const storageKey = \"scores\";\n  return {\n    get: (): Map<string, Score> => {\n      const json: Record<string, Score> = JSON.parse(\n        localStorage.getItem(storageKey) ?? \"{}\",\n      );\n      const scores = new Map<string, Score>();\n      for (const [playerName, playerScore] of Object.entries(json)) {\n        scores.set(playerName, playerScore);\n      }\n      return scores;\n    },\n    set: (scores: Map<string, Score>) => {\n      const json: Record<string, Score> = {};\n      for (const [playerName, playerScore] of scores.entries()) {\n        json[playerName] = playerScore;\n      }\n      localStorage.setItem(storageKey, JSON.stringify(json));\n    },\n    clear: (scores: Map<string, Score>) => {\n      scores.clear();\n      localStorage.setItem(storageKey, \"{}\");\n    },\n  } as const;\n}\n\nfunction getStaticHtmlElements() {\n  function getByIdOptional<T extends HTMLElement = HTMLElement>(\n    id: string,\n  ): T | null {\n    return document.getElementById(id) as T | null;\n  }\n  const add = getByIdOptional<HTMLButtonElement>(\"add-player\");\n  const reset = getByIdOptional<HTMLButtonElement>(\"reset\");\n  const save = getByIdOptional<HTMLButtonElement>(\"save\");\n  const playerName = getByIdOptional<HTMLInputElement>(\"player-name\");\n  const playerList = getByIdOptional<HTMLUListElement>(\"player-list\");\n\n  assert(add !== null, \"Button to add player not found.\");\n  assert(reset !== null, \"Button to erase game data not found.\");\n  assert(save !== null, \"Button to save game data not found.\");\n  assert(playerName !== null, \"Text input for players's names not found.\");\n  assert(playerList !== null, \"List element not found.\");\n\n  return { add, reset, save, playerName, playerList } as const;\n}\n\nwindow.onload = () => main(getStaticHtmlElements());\n"],
  "mappings": "mBAyBO,SAASA,EACdC,EACAC,EAC4B,CAC5B,IAAMC,EAAO,SAAS,cAAcF,CAAG,EACvC,OAAIC,IAAY,OACPC,GAELD,EAAQ,KACVC,EAAK,GAAKD,EAAQ,IAEbE,EACLC,EACEC,EACEC,EAAWC,EAAWL,EAAMD,EAAQ,SAAS,EAAGA,EAAQ,WAAW,EACnEA,EAAQ,UACV,EACAA,EAAQ,QACV,EACAA,EAAQ,SACV,EACF,CAsBA,SAASO,EACPC,EACAC,EACG,CACH,GAAIA,EACF,OAAW,CAACC,EAAMC,CAAQ,IAAK,OAAO,QAAQF,CAAS,EACjDE,aAAoB,MACtBH,EAAK,iBAAiBE,EAAMC,EAAS,GAAIA,EAAS,EAAE,EAC3CA,aAAoB,UAC7BH,EAAK,iBAAiBE,EAAMC,CAAQ,EAI1C,OAAOH,CACT,CAEA,SAASI,EACPJ,EACAK,EACG,CACH,SAASC,EAAUC,EAAwB,CACzC,OAAIA,aAAkB,KACbA,EAEFC,EAAWD,EAAO,GAAIA,EAAO,EAAE,CACxC,CACA,GAAIF,GAAYA,EAAS,OAAS,EAChC,QAAWI,KAASJ,EAClBL,EAAK,OAAOM,EAAUG,CAAK,CAAC,EAGhC,OAAOT,CACT,CAEA,SAASU,EACPV,EACAW,EACG,CACH,GAAIA,EACF,OAAW,CAACC,EAAeC,CAAK,IAAK,OAAO,QAAQF,CAAU,EAC5DX,EAAK,aAAaY,EAAeC,CAAK,EAG1C,OAAOb,CACT,CAEA,SAASc,EACPd,EACAe,EACG,CACH,OAAIA,IACE,OAAOA,GAAgB,SACzBf,EAAK,YAAce,EACVA,EAAY,OACrBf,EAAK,UAAYe,EAAY,OAG1Bf,CACT,CAEA,SAASgB,EACPhB,EACAiB,EACG,CACH,OAAIA,IACE,OAAOA,GAAc,UAAYA,IAAc,IACjDjB,EAAK,UAAU,IAAIiB,CAAS,EAE1BA,aAAqB,OACvBjB,EAAK,UAAU,IAAI,GAAGiB,EAAU,OAAO,OAAO,CAAC,GAG5CjB,CACT,CCtIA,IAAMkB,EAAO,iCAEb,SAASC,EAAK,CAAE,IAAAC,EAAK,MAAAC,EAAO,KAAAC,EAAM,WAAAC,EAAY,WAAAC,CAAW,EAAe,CACtE,IAAMC,EAAQC,EAAa,EACrBC,EAASF,EAAM,IAAI,EACzBD,EAAW,OAAO,GAAGI,EAAoBD,CAAM,CAAC,EAChDP,EAAI,iBAAiB,QAASS,EAAUF,EAAQH,EAAYD,CAAU,CAAC,EACvEF,EAAM,iBAAiB,QAAS,IAAM,CACpC,MAAM,KAAKG,EAAW,QAAQ,EAAE,QAAS,GAAM,EAAE,OAAO,CAAC,EACzDC,EAAM,MAAME,CAAM,CACpB,CAAC,EACDL,EAAK,iBAAiB,QAAS,IAAMG,EAAM,IAAIE,CAAM,CAAC,CACxD,CAEA,SAASC,EAAoBD,EAA4B,CACvD,OAAO,MAAM,KACXA,EAAO,KAAK,EACXJ,GAAeO,EAAmBP,EAAYI,CAAM,CACvD,CACF,CAEA,SAASE,EACPF,EACAI,EACAC,EACA,CACA,MAAO,IAAM,CACX,IAAMT,EAAaS,EAAM,MACrBT,IAAe,IAAM,CAACI,EAAO,IAAIJ,CAAU,IAC7CQ,EAAK,OAAOD,EAAmBP,EAAYI,CAAM,CAAC,EAClDK,EAAM,MAAQ,GAElB,CACF,CAEA,SAASF,EAAmBP,EAAoBI,EAA4B,CA1C5E,IAAAM,EA2CE,IAAMC,EAAcP,EAAO,IACzBJ,GACAU,EAAAN,EAAO,IAAIJ,CAAU,IAArB,KAAAU,EAA0B,CAAE,MAAO,CAAE,CACvC,EAAE,IAAIV,CAAU,EAChBY,EAAOD,IAAgB,MAAS,EAChC,IAAME,EAAYC,EAAW,OAAQ,CACnC,YAAaH,EAAY,MAAM,SAAS,CAC1C,CAAC,EACD,OAAOG,EAAW,KAAM,CACtB,YAAa,GAAGd,OAChB,SAAU,CACRa,EACA,CACE,SACA,CACE,YAAa,KACb,UAAW,CACT,MAAO,IAAM,CACXF,EAAY,OAAS,EACrBE,EAAU,YAAcF,EAAY,MAAM,SAAS,EACnD,IAAI,MAAMhB,CAAI,EAAE,KAAK,CACvB,CACF,CACF,CACF,CACF,CACF,CAAC,CACH,CAEA,SAASiB,EAAOG,EAAoBC,EAAiC,CACnE,GAAI,CAACD,EACH,MAAM,IAAI,MAAMC,CAAG,CAEvB,CAEA,SAASb,GAAe,CACtB,IAAMc,EAAa,SACnB,MAAO,CACL,IAAK,IAA0B,CAjFnC,IAAAP,EAkFM,IAAMQ,EAA8B,KAAK,OACvCR,EAAA,aAAa,QAAQO,CAAU,IAA/B,KAAAP,EAAoC,IACtC,EACMN,EAAS,IAAI,IACnB,OAAW,CAACJ,EAAYW,CAAW,IAAK,OAAO,QAAQO,CAAI,EACzDd,EAAO,IAAIJ,EAAYW,CAAW,EAEpC,OAAOP,CACT,EACA,IAAMA,GAA+B,CACnC,IAAMc,EAA8B,CAAC,EACrC,OAAW,CAAClB,EAAYW,CAAW,IAAKP,EAAO,QAAQ,EACrDc,EAAKlB,GAAcW,EAErB,aAAa,QAAQM,EAAY,KAAK,UAAUC,CAAI,CAAC,CACvD,EACA,MAAQd,GAA+B,CACrCA,EAAO,MAAM,EACb,aAAa,QAAQa,EAAY,IAAI,CACvC,CACF,CACF,CAEA,SAASE,GAAwB,CAC/B,SAASC,EACPC,EACU,CACV,OAAO,SAAS,eAAeA,CAAE,CACnC,CACA,IAAMxB,EAAMuB,EAAmC,YAAY,EACrDtB,EAAQsB,EAAmC,OAAO,EAClDrB,EAAOqB,EAAmC,MAAM,EAChDpB,EAAaoB,EAAkC,aAAa,EAC5DnB,EAAamB,EAAkC,aAAa,EAElE,OAAAR,EAAOf,IAAQ,KAAM,iCAAiC,EACtDe,EAAOd,IAAU,KAAM,sCAAsC,EAC7Dc,EAAOb,IAAS,KAAM,qCAAqC,EAC3Da,EAAOZ,IAAe,KAAM,2CAA2C,EACvEY,EAAOX,IAAe,KAAM,yBAAyB,EAE9C,CAAE,IAAAJ,EAAK,MAAAC,EAAO,KAAAC,EAAM,WAAAC,EAAY,WAAAC,CAAW,CACpD,CAEA,OAAO,OAAS,IAAML,EAAKuB,EAAsB,CAAC",
  "names": ["createNode", "tag", "options", "node", "addListeners", "addChildren", "addAttributes", "addContent", "addClasses", "addListeners", "node", "listeners", "name", "listener", "addChildren", "children", "makeChild", "params", "createNode", "child", "addAttributes", "attributes", "attributeName", "value", "addContent", "textContent", "addClasses", "classList", "DING", "main", "add", "reset", "save", "playerName", "playerList", "state", "stateManager", "scores", "initialPlayingBoard", "addPlayer", "makePlayerListItem", "list", "input", "_a", "playerScore", "assert", "scoreNode", "createNode", "condition", "msg", "storageKey", "json", "getStaticHtmlElements", "getByIdOptional", "id"]
}
